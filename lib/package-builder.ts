/**
 * npm package builder
 * Generates a source package (no pre-compilation) from saved components
 */

import { mkdir, writeFile, rm } from 'node:fs/promises';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { join } from 'node:path';
import { readFile } from 'node:fs/promises';

const execAsync = promisify(exec);

export interface BuildOptions {
  components: Array<{
    name: string;
    component_code: string;
    css_code: string;
  }>;
  packageName: string;
  version: string;
}

export interface BuildResult {
  tarballBuffer: Buffer;
  tarballFilename: string;
  buildLog: string[];
}

/**
 * Build an npm package from components
 */
export async function buildPackage(
  options: BuildOptions,
): Promise<BuildResult> {
  const buildLog: string[] = [];
  const tempDir = join('/tmp', `package-build-${Date.now()}`);
  buildLog.push(`Creating temp directory: ${tempDir}`);

  try {
    // 1. Create directory structure
    await mkdir(tempDir, { recursive: true });
    await mkdir(join(tempDir, 'src'), { recursive: true });

    // 2. Generate package.json
    const packageJson = {
      name: options.packageName,
      version: options.version,
      description: 'UI components generated from Figma',
      main: 'src/index.ts',
      types: 'src/index.ts',
      type: 'module',
      files: ['src/**/*'],
      peerDependencies: {
        react: '^18.0.0 || ^19.0.0',
        'react-dom': '^18.0.0 || ^19.0.0',
      },
      keywords: ['react', 'components', 'figma', 'ui'],
      license: 'MIT',
    };

    await writeFile(
      join(tempDir, 'package.json'),
      JSON.stringify(packageJson, null, 2),
    );
    buildLog.push('Generated package.json');

    // 3. Generate tsconfig.json
    const tsconfig = {
      compilerOptions: {
        target: 'ES2020',
        module: 'ESNext',
        lib: ['ES2020', 'DOM', 'DOM.Iterable'],
        jsx: 'react-jsx',
        declaration: true,
        declarationMap: true,
        outDir: 'dist',
        moduleResolution: 'bundler',
        allowImportingTsExtensions: true,
        resolveJsonModule: true,
        isolatedModules: true,
        esModuleInterop: true,
        strict: true,
        skipLibCheck: true,
      },
      include: ['src/**/*'],
    };

    await writeFile(
      join(tempDir, 'tsconfig.json'),
      JSON.stringify(tsconfig, null, 2),
    );
    buildLog.push('Generated tsconfig.json');

    // 4. Generate README.md
    const readme = `# ${options.packageName}

UI components generated from Figma designs.

## Installation

\`\`\`bash
npm install ${options.packageName}-${options.version}.tgz
\`\`\`

## Usage

\`\`\`tsx
import { ${options.components.map((c) => c.name).join(', ')} } from '${options.packageName}';

function App() {
  return <${options.components[0]?.name || 'Component'} />;
}
\`\`\`

## Components

${options.components.map((c) => `- ${c.name}`).join('\n')}

## Generated by

[Figma to React Code Generator](https://github.com/your-org/federation-figma-to-react)
`;

    await writeFile(join(tempDir, 'README.md'), readme);
    buildLog.push('Generated README.md');

    // 5. Write component files
    for (const component of options.components) {
      const componentDir = join(tempDir, 'src', component.name);
      await mkdir(componentDir, { recursive: true });

      // Write TSX file
      await writeFile(
        join(componentDir, `${component.name}.tsx`),
        component.component_code,
      );

      // Write CSS Module file
      await writeFile(
        join(componentDir, `${component.name}.module.css`),
        component.css_code,
      );

      buildLog.push(`Created ${component.name}/`);
    }

    // 6. Generate index.ts (barrel export)
    const indexContent = options.components
      .map((c) => `export { default as ${c.name} } from './${c.name}/${c.name}';`)
      .join('\n');

    await writeFile(join(tempDir, 'src', 'index.ts'), indexContent);
    buildLog.push('Generated src/index.ts');

    // 7. Create tarball using npm pack
    buildLog.push('Running npm pack...');
    const { stdout } = await execAsync('npm pack', { cwd: tempDir });
    const tarballFilename = stdout.trim();
    buildLog.push(`Created tarball: ${tarballFilename}`);

    // 8. Read tarball buffer
    const tarballPath = join(tempDir, tarballFilename);
    const tarballBuffer = await readFile(tarballPath);
    buildLog.push(`Read tarball (${tarballBuffer.length} bytes)`);

    // 9. Cleanup temp directory
    await rm(tempDir, { recursive: true, force: true });
    buildLog.push('Cleaned up temp directory');

    return {
      tarballBuffer,
      tarballFilename,
      buildLog,
    };
  } catch (error) {
    // Cleanup on error
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }

    buildLog.push(`ERROR: ${error instanceof Error ? error.message : 'Unknown error'}`);
    throw error;
  }
}
